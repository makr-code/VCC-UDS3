"""Quick script to convert parameter annotations like `name: str = None` into
`name: Optional[str] = None` across the codebase.

This is a pragmatic codemod to reduce common mypy "Incompatible default" noise.
It handles common builtin and typing names (str,int,float,bool,list,dict,Dict,List,Any).
It will also add `from typing import Optional` at the top of modules that need it.

Run carefully and review changes in a PR. It's intentionally conservative.
"""
import re
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
PY_PATTERN = "**/*.py"

# Map simple type names to their Optional form template
SIMPLE_TYPES = {
    "str": "Optional[str]",
    "int": "Optional[int]",
    "float": "Optional[float]",
    "bool": "Optional[bool]",
    "list": "Optional[list[Any]]",
    "dict": "Optional[dict[Any, Any]]",
    "List": "Optional[List[Any]]",
    "Dict": "Optional[Dict[Any, Any]]",
    "Any": "Optional[Any]",
}

# Regex to find parameter annotations with a simple type and default None
PARAM_RE = re.compile(r"(?P<prefix>\b[\w_]+\s*:\s*)(?P<type>str|int|float|bool|list|dict|List|Dict|Any)\s*=\s*None\b")


def process_file(path: Path) -> bool:
    text = path.read_text(encoding="utf-8")
    # Skip files that are likely generated or in venv
    if "# noqa" in text and "autogenerated" in text.lower():
        return False

    new_text = PARAM_RE.sub(lambda m: m.group("prefix") + SIMPLE_TYPES[m.group("type")] + " = None", text)
    if new_text == text:
        return False

    # Ensure Optional import exists
    if "Optional" in new_text and "from typing import Optional" not in new_text:
        # Try to insert after other typing imports or at top
        lines = new_text.splitlines()
        insert_at = 0
        for i, line in enumerate(lines[:50]):
            if line.startswith("from typing"):
                insert_at = i + 1
        lines.insert(insert_at, "from typing import Optional, Any")
        new_text = "\n".join(lines)

    path.write_text(new_text, encoding="utf-8")
    print(f"Patched: {path}")
    return True


def main() -> None:
    patched = 0
    for p in ROOT.glob(PY_PATTERN):
        # skip venv, __pycache__, third_party_stubs
        if any(part in (".venv", "__pycache__", "third_party_stubs", "docs", "security") for part in p.parts):
            continue
        try:
            if process_file(p):
                patched += 1
        except Exception as exc:
            print(f"Error processing {p}: {exc}")
    print(f"Done. Files patched: {patched}")


if __name__ == "__main__":
    main()
