#!/usr/bin/env python3
"""
UDS3 Relations Schema Core - VERITAS Knowledge Graph Relations Framework
========================================================================
Kernkomponente für die Unified Database Strategy v3.0 Relations-Verwaltung
Integriert den Relations Almanach direkt in das UDS3-Framework mit Neo4j Backend
"""

import logging
from typing import Dict, List, Any
from datetime import datetime
from dataclasses import dataclass, field
from enum import Enum
from neo4j import GraphDatabase
from contextlib import contextmanager

from typing import Any
from typing import Optional, Any

# Fallback-Stubs für das Veritas Relations Almanach (lokales Paket / optional)
VERITASRelationAlmanach: Any = Any  # type: ignore
RelationType: Any = Any  # type: ignore
GraphLevel: Any = Any  # type: ignore
RelationDefinition: Any = Any  # type: ignore

logger = logging.getLogger(__name__)


class UDS3RelationPriority(Enum):
    """UDS3-spezifische Relation-Prioritäten"""

    CRITICAL = "critical"  # Systemkritische Relations (PART_OF, CONTAINS_CHUNK)
    LEGAL = "legal"  # Rechtliche Relations (UDS3_LEGAL_REFERENCE)
    SEMANTIC = "semantic"  # Semantische Relations (UDS3_SEMANTIC_REFERENCE)
    STRUCTURAL = "structural"  # Strukturelle Relations (NEXT_CHUNK, etc.)
    QUALITY = "quality"  # Qualitäts-Relations
    SYSTEM = "system"  # System-Relations


class UDS3RelationStatus(Enum):
    """Status einer Relation im UDS3-System"""

    ACTIVE = "active"
    DEPRECATED = "deprecated"
    EXPERIMENTAL = "experimental"
    LEGACY = "legacy"
    PLANNED = "planned"


@dataclass
class UDS3RelationMetadata:
    """Erweiterte Metadaten für UDS3 Relations"""

    relation_name: str
    uds3_priority: UDS3RelationPriority
    status: UDS3RelationStatus
    neo4j_optimized: bool = True
    index_required: bool = True
    constraint_required: bool = False
    performance_weight: float = 1.0
    legal_compliance: bool = True
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    version: str = "3.0"


class UDS3RelationsCore:
    """
    Kern-Klasse für UDS3 Relations Management
    Integriert Relations Almanach mit Neo4j Graph Database Backend
    """

    def __init__(
        self,
        neo4j_uri: str = "neo4j://127.0.0.1:7687",
        neo4j_auth: tuple = ("neo4j", "v3f3b1d7"),
    ):
        """
        Initialisiert UDS3 Relations Core mit Neo4j Verbindung

        Args:
            neo4j_uri: Neo4j Database URI
            neo4j_auth: Authentication tuple (username, password)
        """
        self.neo4j_uri = neo4j_uri
        self.neo4j_auth = neo4j_auth
        self.driver = None

        # Relations Almanach laden
        self.almanach = VERITASRelationAlmanach()

        # UDS3-spezifische Relations Metadaten
        self.uds3_relation_metadata = self._initialize_uds3_metadata()

        # Performance Cache für häufig verwendete Relations
        self.relation_cache: dict[Any, Any] = {}

        # Initialisiere Neo4j Connection
        self._initialize_neo4j_connection()

        logger.info("UDS3 Relations Core initialisiert")

    def _initialize_neo4j_connection(self):
        """Initialisiert Neo4j Datenbankverbindung"""
        try:
            self.driver = GraphDatabase.driver(self.neo4j_uri, auth=self.neo4j_auth)
            # Test Connection
            with self.driver.session() as session:
                result = session.run("RETURN 1 as test")
                test_value = result.single()["test"]
                if test_value == 1:
                    logger.info("✅ Neo4j Verbindung erfolgreich")
                else:
                    raise Exception("Neo4j Connection Test fehlgeschlagen")
        except Exception as e:
            logger.error(f"❌ Neo4j Verbindung fehlgeschlagen: {e}")
            raise

    @contextmanager
    def neo4j_session(self):
        """Context Manager für Neo4j Sessions"""
        session = self.driver.session()
        try:
            yield session
        finally:
            session.close()

    def _initialize_uds3_metadata(self) -> Dict[str, UDS3RelationMetadata]:
        """Initialisiert UDS3-spezifische Metadaten für alle Relations"""
        metadata: dict[Any, Any] = {}

        # Hole alle Relations aus dem Almanach
        for relation_name, relation_def in self.almanach.relations.items():
            # Bestimme UDS3 Priorität basierend auf Relation-Typ und Namen
            if relation_name.startswith("UDS3_"):
                priority = (
                    UDS3RelationPriority.LEGAL
                    if "LEGAL" in relation_name
                    else UDS3RelationPriority.SEMANTIC
                )
            elif relation_name in [
                "PART_OF",
                "CONTAINS_CHUNK",
                "NEXT_CHUNK",
                "PREVIOUS_CHUNK",
            ]:
                priority = UDS3RelationPriority.CRITICAL
            elif relation_def.type == RelationType.LEGAL:
                priority = UDS3RelationPriority.LEGAL
            elif relation_def.type == RelationType.SEMANTIC:
                priority = UDS3RelationPriority.SEMANTIC
            elif relation_def.type == RelationType.STRUCTURAL:
                priority = UDS3RelationPriority.STRUCTURAL
            elif relation_def.type == RelationType.QUALITY:
                priority = UDS3RelationPriority.QUALITY
            else:
                priority = UDS3RelationPriority.SYSTEM

            # Bestimme Status
            status = UDS3RelationStatus.ACTIVE
            if relation_name.startswith("UDS3_"):
                status = UDS3RelationStatus.ACTIVE
            elif relation_def.kge_importance == "critical":
                status = UDS3RelationStatus.ACTIVE
            else:
                status = UDS3RelationStatus.ACTIVE  # Alle Relations standardmäßig aktiv

            # Erstelle Metadaten
            metadata[relation_name] = UDS3RelationMetadata(
                relation_name=relation_name,
                uds3_priority=priority,
                status=status,
                neo4j_optimized=True,
                index_required=relation_def.kge_importance in ["critical", "high"],
                constraint_required=relation_name in ["PART_OF", "CONTAINS_CHUNK"],
                performance_weight=self._calculate_performance_weight(relation_def),
                legal_compliance=relation_def.uds3_compliance,
            )

        return metadata

    def _calculate_performance_weight(self, relation_def: Any) -> float:
        """Berechnet Performance-Gewichtung für eine Relation"""
        weight = 1.0

        # KGE Wichtigkeit beeinflusst Weight
        kge_weights = {"critical": 2.0, "high": 1.5, "medium": 1.0, "low": 0.5}
        weight *= kge_weights.get(relation_def.kge_importance, 1.0)

        # Transitivität erhöht Weight (mehr Traversal-Operationen)
        if relation_def.transitivity:
            weight *= 1.3

        # UDS3-spezifische Relations haben höheres Weight
        if relation_def.name.startswith("UDS3_"):
            weight *= 1.8

        return round(weight, 2)

    # ================================================================
    # NEO4J SCHEMA MANAGEMENT
    # ================================================================

    def create_neo4j_schema(self, force_recreate: bool = False) -> Dict:
        """
        Erstellt vollständiges Neo4j Schema basierend auf Relations Almanach

        Args:
            force_recreate: Erzwingt Neuerstellung bestehender Constraints/Indexes

        Returns:
            Dict: Schema-Erstellungsergebnis
        """
        schema_result = {
            "timestamp": datetime.now().isoformat(),
            "force_recreate": force_recreate,
            "constraints_created": [],
            "indexes_created": [],
            "relation_types_defined": [],
            "errors": [],
            "success": True,
        }

        try:
            with self.neo4j_session() as session:
                # 1. Node Constraints erstellen
                constraints_created = self._create_node_constraints(
                    session, force_recreate
                )
                schema_result["constraints_created"] = constraints_created

                # 2. Property Indexes erstellen
                indexes_created = self._create_property_indexes(session, force_recreate)
                schema_result["indexes_created"] = indexes_created

                # 3. Relation-Type Definitionen (für Dokumentation)
                relation_types = self._document_relation_types(session)
                schema_result["relation_types_defined"] = relation_types

                # 4. UDS3-spezifische Optimierungen
                uds3_optimizations = self._apply_uds3_optimizations(session)
                schema_result["uds3_optimizations"] = uds3_optimizations

                logger.info(
                    f"✅ Neo4j Schema erfolgreich erstellt: {len(constraints_created)} Constraints, {len(indexes_created)} Indexes"
                )

        except Exception as e:
            schema_result["success"] = False
            schema_result["errors"].append(str(e))
            logger.error(f"❌ Neo4j Schema-Erstellung fehlgeschlagen: {e}")

        return schema_result

    def _create_node_constraints(self, session, force_recreate: bool) -> List[str]:
        """Erstellt Node-Constraints für kritische Node-Typen"""
        constraints_created: list[Any] = []

        # Standard Node-Constraints
        standard_constraints = [
            "CREATE CONSTRAINT document_id_unique IF NOT EXISTS FOR (d:Document) REQUIRE d.id IS UNIQUE",
            "CREATE CONSTRAINT document_chunk_id_unique IF NOT EXISTS FOR (c:DocumentChunk) REQUIRE c.chunk_id IS UNIQUE",
            "CREATE CONSTRAINT legal_reference_id_unique IF NOT EXISTS FOR (l:LegalReference) REQUIRE l.id IS UNIQUE",
            "CREATE CONSTRAINT legal_reference_node_id_unique IF NOT EXISTS FOR (l:Legal-Reference-Node) REQUIRE l.id IS UNIQUE",
        ]

        for constraint_cypher in standard_constraints:
            try:
                if force_recreate:
                    # Versuche Constraint zu löschen (falls vorhanden)
                    constraint_name = self._extract_constraint_name(constraint_cypher)
                    try:
                        session.run(f"DROP CONSTRAINT {constraint_name} IF EXISTS")
                    except:
                        pass  # Constraint existierte nicht

                session.run(constraint_cypher)
                constraint_name = self._extract_constraint_name(constraint_cypher)
                constraints_created.append(constraint_name)
                logger.debug(f"✅ Constraint erstellt: {constraint_name}")

            except Exception as e:
                logger.warning(f"⚠️ Constraint bereits vorhanden oder Fehler: {e}")

        return constraints_created

    def _create_property_indexes(self, session, force_recreate: bool) -> List[str]:
        """Erstellt Property-Indexes für Performance-kritische Properties"""
        indexes_created: list[Any] = []

        # Indexes basierend auf Relations Almanach
        critical_indexes = [
            # Document Indexes
            "CREATE INDEX document_rechtsgebiet_idx IF NOT EXISTS FOR (d:Document) ON (d.rechtsgebiet)",
            "CREATE INDEX document_behoerde_idx IF NOT EXISTS FOR (d:Document) ON (d.behoerde)",
            "CREATE INDEX document_type_idx IF NOT EXISTS FOR (d:Document) ON (d.document_type)",
            "CREATE INDEX document_created_at_idx IF NOT EXISTS FOR (d:Document) ON (d.created_at)",
            "CREATE INDEX document_file_hash_idx IF NOT EXISTS FOR (d:Document) ON (d.file_hash)",
            # DocumentChunk Indexes
            "CREATE INDEX chunk_chunk_index_idx IF NOT EXISTS FOR (c:DocumentChunk) ON (c.chunk_index)",
            "CREATE INDEX chunk_document_id_idx IF NOT EXISTS FOR (c:DocumentChunk) ON (c.document_id)",
            "CREATE INDEX chunk_chunk_type_idx IF NOT EXISTS FOR (c:DocumentChunk) ON (c.chunk_type)",
            # Legal Reference Indexes
            "CREATE INDEX legal_ref_reference_type_idx IF NOT EXISTS FOR (l:LegalReference) ON (l.reference_type)",
            "CREATE INDEX legal_ref_law_code_idx IF NOT EXISTS FOR (l:LegalReference) ON (l.law_code)",
            "CREATE INDEX legal_ref_paragraph_idx IF NOT EXISTS FOR (l:LegalReference) ON (l.paragraph)",
            # Relationship-Property Indexes (für UDS3 Relations)
            "CREATE INDEX rel_uds3_legal_ref_confidence_idx IF NOT EXISTS FOR ()-[r:UDS3_LEGAL_REFERENCE]-() ON (r.confidence)",
            "CREATE INDEX rel_uds3_semantic_ref_similarity_idx IF NOT EXISTS FOR ()-[r:UDS3_SEMANTIC_REFERENCE]-() ON (r.similarity_score)",
        ]

        for index_cypher in critical_indexes:
            try:
                if force_recreate:
                    # Versuche Index zu löschen (falls vorhanden)
                    index_name = self._extract_index_name(index_cypher)
                    try:
                        session.run(f"DROP INDEX {index_name} IF EXISTS")
                    except:
                        pass  # Index existierte nicht

                session.run(index_cypher)
                index_name = self._extract_index_name(index_cypher)
                indexes_created.append(index_name)
                logger.debug(f"✅ Index erstellt: {index_name}")

            except Exception as e:
                logger.warning(f"⚠️ Index bereits vorhanden oder Fehler: {e}")

        return indexes_created

    def _document_relation_types(self, session) -> List[str]:
        """Dokumentiert alle Relation-Typen im Graph für Referenz"""
        relation_types: list[Any] = []

        # Erstelle Meta-Nodes für alle Relations (optional, für Dokumentation)
        for relation_name, relation_def in self.almanach.relations.items():
            meta_properties = {
                "name": relation_name,
                "type": relation_def.type.value,
                "level": relation_def.level.value,
                "description": relation_def.description,
                "kge_importance": relation_def.kge_importance,
                "uds3_compliance": relation_def.uds3_compliance,
                "created_at": datetime.now().isoformat(),
            }

            # Optional: Erstelle Meta-Node (nur bei Bedarf)
            # cypher = """
            # MERGE (r:RelationType {name: $name})
            # SET r += $properties
            # """
            # session.run(cypher, name=relation_name, properties=meta_properties)

            relation_types.append(relation_name)

        return relation_types

    def _apply_uds3_optimizations(self, session) -> List[str]:
        """Wendet UDS3-spezifische Neo4j Optimierungen an"""
        optimizations: list[Any] = []

        # UDS3-spezifische Composite Indexes
        uds3_optimizations = [
            # Composite Index für häufige UDS3-Abfragen
            "CREATE INDEX uds3_document_composite_idx IF NOT EXISTS FOR (d:Document) ON (d.rechtsgebiet, d.document_type, d.created_at)",
            # Fulltext Index für Content-Suche
            "CREATE FULLTEXT INDEX uds3_document_content_fulltext IF NOT EXISTS FOR (d:Document|c:DocumentChunk) ON EACH [d.title, d.content_preview, c.content_preview]",
            # Compound Index für Legal References
            "CREATE INDEX uds3_legal_ref_compound_idx IF NOT EXISTS FOR (l:LegalReference) ON (l.law_code, l.paragraph, l.reference_type)",
        ]

        for optimization_cypher in uds3_optimizations:
            try:
                session.run(optimization_cypher)
                opt_name = self._extract_index_name(optimization_cypher)
                optimizations.append(opt_name)
                logger.debug(f"✅ UDS3 Optimierung angewendet: {opt_name}")

            except Exception as e:
                logger.warning(f"⚠️ UDS3 Optimierung bereits vorhanden oder Fehler: {e}")

        return optimizations

    def _extract_constraint_name(self, cypher: str) -> str:
        """Extrahiert Constraint-Namen aus Cypher-Statement"""
        # Vereinfachte Extraktion - in Production robuster implementieren
        if "CREATE CONSTRAINT" in cypher and "IF NOT EXISTS" in cypher:
            parts = cypher.split()
            for i, part in enumerate(parts):
                if part == "CONSTRAINT" and i + 1 < len(parts):
                    return parts[i + 1]
        return "unknown_constraint"

    def _extract_index_name(self, cypher: str) -> str:
        """Extrahiert Index-Namen aus Cypher-Statement"""
        # Vereinfachte Extraktion - in Production robuster implementieren
        if "CREATE INDEX" in cypher or "CREATE FULLTEXT INDEX" in cypher:
            parts = cypher.split()
            for i, part in enumerate(parts):
                if part == "INDEX" and i + 1 < len(parts):
                    return parts[i + 1]
        return "unknown_index"

    # ================================================================
    # RELATION OPERATIONS
    # ================================================================

    def create_relation(
        self,
        source_node_id: str,
        target_node_id: str,
        relation_type: str,
        properties: Optional[Dict[Any, Any]] = None,
        source_node_type: Optional[str] = None,
        target_node_type: Optional[str] = None,
    ) -> Dict:
        """
        Erstellt eine neue Relation zwischen zwei Nodes

        Args:
            source_node_id: ID des Quell-Nodes
            target_node_id: ID des Ziel-Nodes
            relation_type: Typ der Relation (aus Almanach)
            properties: Zusätzliche Relation-Properties
            source_node_type: Typ des Quell-Nodes (optional)
            target_node_type: Typ des Ziel-Nodes (optional)

        Returns:
            Dict: Ergebnis der Relation-Erstellung
        """
        operation_result = {
            "timestamp": datetime.now().isoformat(),
            "operation": "CREATE_RELATION",
            "source_node_id": source_node_id,
            "target_node_id": target_node_id,
            "relation_type": relation_type,
            "properties": properties or {},
            "success": False,
            "relation_id": None,
            "validation_errors": [],
            "performance_metrics": {},
        }

        start_time = datetime.now()

        try:
            # 1. Validiere Relation-Typ
            if relation_type not in self.almanach.relations:
                operation_result["validation_errors"].append(
                    f"Unbekannter Relation-Typ: {relation_type}"
                )
                return operation_result

            relation_def = self.almanach.relations[relation_type]

            # 2. Validiere Node-Typen (falls angegeben)
            if (
                source_node_type
                and source_node_type not in relation_def.source_node_types
            ):
                operation_result["validation_errors"].append(
                    f"Source Node Type {source_node_type} nicht erlaubt für {relation_type}"
                )

            if (
                target_node_type
                and target_node_type not in relation_def.target_node_types
            ):
                operation_result["validation_errors"].append(
                    f"Target Node Type {target_node_type} nicht erlaubt für {relation_type}"
                )

            if operation_result["validation_errors"]:
                return operation_result

            # 3. Erweitere Properties mit UDS3-Metadaten
            enhanced_properties = self._enhance_relation_properties(
                relation_type, properties or {}
            )

            # 4. Erstelle Relation in Neo4j
            with self.neo4j_session() as session:
                cypher = f"""
                MATCH (source), (target)
                WHERE source.id = $source_id AND target.id = $target_id
                CREATE (source)-[r:{relation_type}]->(target)
                SET r += $properties
                RETURN r, id(r) as relation_id
                """

                result = session.run(
                    cypher,
                    source_id=source_node_id,
                    target_id=target_node_id,
                    properties=enhanced_properties,
                )

                record = result.single()
                if record:
                    operation_result["success"] = True
                    operation_result["relation_id"] = record["relation_id"]

                    # 5. Erstelle inverse Relation falls definiert
                    if relation_def.inverse_relation:
                        self._create_inverse_relation(
                            session,
                            target_node_id,
                            source_node_id,
                            relation_def.inverse_relation,
                            enhanced_properties,
                        )

            # Performance Metrics
            end_time = datetime.now()
            operation_result["performance_metrics"] = {
                "duration_ms": int((end_time - start_time).total_seconds() * 1000),
                "relation_priority": self.uds3_relation_metadata[
                    relation_type
                ].uds3_priority.value,
                "performance_weight": self.uds3_relation_metadata[
                    relation_type
                ].performance_weight,
            }

            logger.info(
                f"✅ Relation erstellt: {relation_type} ({source_node_id} -> {target_node_id})"
            )

        except Exception as e:
            operation_result["validation_errors"].append(f"Neo4j Fehler: {str(e)}")
            logger.error(f"❌ Relation-Erstellung fehlgeschlagen: {e}")

        return operation_result

    def _enhance_relation_properties(
        self, relation_type: str, properties: Dict
    ) -> Dict:
        """Erweitert Relation-Properties mit UDS3-Metadaten"""
        enhanced_properties = properties.copy()

        # UDS3-Standard Properties
        enhanced_properties.update(
            {
                "uds3_created_at": datetime.now().isoformat(),
                "uds3_relation_version": "3.0",
                "uds3_priority": self.uds3_relation_metadata[
                    relation_type
                ].uds3_priority.value,
                "uds3_performance_weight": self.uds3_relation_metadata[
                    relation_type
                ].performance_weight,
            }
        )

        # Relation-spezifische Defaults
        relation_def = self.almanach.relations[relation_type]
        for prop_name, prop_type in relation_def.properties.items():
            if prop_name not in enhanced_properties:
                # Standard-Werte basierend auf Property-Typ
                if prop_type == "float":
                    enhanced_properties[prop_name] = 1.0
                elif prop_type == "int":
                    enhanced_properties[prop_name] = 0
                elif prop_type == "bool":
                    enhanced_properties[prop_name] = True
                elif prop_type == "str":
                    enhanced_properties[prop_name] = "auto_generated"

        return enhanced_properties

    def _create_inverse_relation(
        self,
        session,
        source_id: str,
        target_id: str,
        inverse_relation_type: str,
        properties: Dict,
    ):
        """Erstellt inverse Relation falls definiert"""
        try:
            cypher = f"""
            MATCH (source), (target)
            WHERE source.id = $source_id AND target.id = $target_id
            CREATE (source)-[r:{inverse_relation_type}]->(target)
            SET r += $properties
            SET r.uds3_inverse_relation = true
            """

            session.run(
                cypher, source_id=source_id, target_id=target_id, properties=properties
            )

            logger.debug(f"✅ Inverse Relation erstellt: {inverse_relation_type}")

        except Exception as e:
            logger.warning(f"⚠️ Inverse Relation konnte nicht erstellt werden: {e}")

    def get_relation_schema(self, relation_type: Optional[str] = None) -> Dict:
        """
        Holt Relation-Schema aus dem Almanach

        Args:
            relation_type: Spezifischer Relation-Typ oder None für alle

        Returns:
            Dict: Relation-Schema-Information
        """
        if relation_type:
            if relation_type not in self.almanach.relations:
                return {"error": f"Relation type {relation_type} not found"}

            relation_def = self.almanach.relations[relation_type]
            uds3_metadata = self.uds3_relation_metadata[relation_type]

            return {
                "relation_type": relation_type,
                "definition": {
                    "type": relation_def.type.value,
                    "level": relation_def.level.value,
                    "description": relation_def.description,
                    "source_node_types": relation_def.source_node_types,
                    "target_node_types": relation_def.target_node_types,
                    "properties": relation_def.properties,
                    "inverse_relation": relation_def.inverse_relation,
                    "transitivity": relation_def.transitivity,
                    "symmetry": relation_def.symmetry,
                    "kge_importance": relation_def.kge_importance,
                },
                "uds3_metadata": {
                    "priority": uds3_metadata.uds3_priority.value,
                    "status": uds3_metadata.status.value,
                    "neo4j_optimized": uds3_metadata.neo4j_optimized,
                    "performance_weight": uds3_metadata.performance_weight,
                    "legal_compliance": uds3_metadata.legal_compliance,
                },
            }
        else:
            # Alle Relations
            return {
                "total_relations": len(self.almanach.relations),
                "relations": {
                    name: self.get_relation_schema(name)
                    for name in self.almanach.relations.keys()
                },
                "uds3_priorities": {
                    priority.value: [
                        name
                        for name, meta in self.uds3_relation_metadata.items()
                        if meta.uds3_priority == priority
                    ]
                    for priority in UDS3RelationPriority
                },
            }

    def validate_graph_consistency(self) -> Dict:
        """Validiert Graph-Konsistenz basierend auf Relations Almanach"""
        validation_result = {
            "timestamp": datetime.now().isoformat(),
            "overall_consistent": True,
            "validation_checks": [],
            "inconsistencies": [],
            "recommendations": [],
            "statistics": {},
        }

        try:
            with self.neo4j_session() as session:
                # 1. Relation-Type Konsistenz
                unknown_relations = self._check_unknown_relations(session)
                if unknown_relations:
                    validation_result["inconsistencies"].extend(unknown_relations)
                    validation_result["overall_consistent"] = False

                # 2. UDS3-spezifische Konsistenz-Checks
                uds3_checks = self._check_uds3_consistency(session)
                validation_result["validation_checks"].extend(uds3_checks)

                # 3. Performance-relevante Checks
                performance_issues = self._check_performance_issues(session)
                if performance_issues:
                    validation_result["recommendations"].extend(performance_issues)

                # 4. Graph-Statistiken
                validation_result["statistics"] = self._collect_graph_statistics(
                    session
                )

        except Exception as e:
            validation_result["overall_consistent"] = False
            validation_result["inconsistencies"].append(
                f"Validierung fehlgeschlagen: {str(e)}"
            )
            logger.error(f"❌ Graph-Validierung fehlgeschlagen: {e}")

        return validation_result

    def _check_unknown_relations(self, session) -> List[str]:
        """Prüft auf unbekannte Relation-Typen"""
        cypher = """
        MATCH ()-[r]->()
        RETURN DISTINCT type(r) as relation_type, count(r) as count
        """

        result = session.run(cypher)
        unknown_relations: list[Any] = []

        for record in result:
            relation_type = record["relation_type"]
            count = record["count"]

            if relation_type not in self.almanach.relations:
                unknown_relations.append(
                    f"Unbekannter Relation-Typ '{relation_type}' ({count} Instanzen)"
                )

        return unknown_relations

    def _check_uds3_consistency(self, session) -> List[Dict]:
        """UDS3-spezifische Konsistenz-Checks"""
        checks: list[Any] = []

        # Check: UDS3_LEGAL_REFERENCE Relations
        cypher = """
        MATCH ()-[r:UDS3_LEGAL_REFERENCE]->()
        WHERE r.confidence IS NULL OR r.uds3_created_at IS NULL
        RETURN count(r) as incomplete_legal_refs
        """
        result = session.run(cypher)
        incomplete_legal = result.single()["incomplete_legal_refs"]

        checks.append(
            {
                "check_name": "UDS3_LEGAL_REFERENCE_completeness",
                "status": "PASS" if incomplete_legal == 0 else "FAIL",
                "details": f"{incomplete_legal} incomplete UDS3_LEGAL_REFERENCE relations found",
            }
        )

        # Check: Dokumentstruktur Konsistenz
        cypher = """
        MATCH (d:Document)
        WHERE NOT (d)-[:CONTAINS_CHUNK]->(:DocumentChunk)
        RETURN count(d) as documents_without_chunks
        """
        result = session.run(cypher)
        docs_without_chunks = result.single()["documents_without_chunks"]

        checks.append(
            {
                "check_name": "document_chunk_consistency",
                "status": "PASS" if docs_without_chunks == 0 else "WARNING",
                "details": f"{docs_without_chunks} documents without chunks found",
            }
        )

        return checks

    def _check_performance_issues(self, session) -> List[str]:
        """Prüft auf Performance-Probleme"""
        recommendations: list[Any] = []

        # Check: Orphaned Nodes
        cypher = """
        MATCH (n)
        WHERE NOT (n)--()
        RETURN count(n) as orphaned_nodes
        """
        result = session.run(cypher)
        orphaned = result.single()["orphaned_nodes"]

        if orphaned > 0:
            recommendations.append(
                f"Entferne {orphaned} verwaiste Nodes für bessere Performance"
            )

        return recommendations

    def _collect_graph_statistics(self, session) -> Dict:
        """Sammelt Graph-Statistiken"""
        stats: dict[Any, Any] = {}

        # Node Counts
        cypher = "MATCH (n) RETURN labels(n) as labels, count(n) as count"
        result = session.run(cypher)
        stats["node_counts"] = {}

        for record in result:
            labels = record["labels"]
            count = record["count"]
            label_key = ":".join(sorted(labels)) if labels else "UNLABELED"
            stats["node_counts"][label_key] = count

        # Relation Counts by Type
        cypher = "MATCH ()-[r]->() RETURN type(r) as rel_type, count(r) as count ORDER BY count DESC"
        result = session.run(cypher)
        stats["relation_counts"] = {}

        for record in result:
            rel_type = record["rel_type"]
            count = record["count"]
            stats["relation_counts"][rel_type] = count

        return stats

    def close(self):
        """Schließt Neo4j Verbindung"""
        if self.driver:
            self.driver.close()
            logger.info("Neo4j Verbindung geschlossen")


# Singleton Pattern für UDS3 Relations Core
_uds3_relations_core: Any = None


def get_uds3_relations_core(
    neo4j_uri: str = "neo4j://127.0.0.1:7687", neo4j_auth: tuple = ("neo4j", "v3f3b1d7")
) -> UDS3RelationsCore:
    """Singleton-Zugriff auf UDS3 Relations Core"""
    global _uds3_relations_core
    if _uds3_relations_core is None:
        _uds3_relations_core = UDS3RelationsCore(neo4j_uri, neo4j_auth)
    return _uds3_relations_core


if __name__ == "__main__":
    print("🔗 UDS3 RELATIONS SCHEMA CORE - NEO4J BACKEND TEST")
    print("=" * 60)

    # Initialisiere UDS3 Relations Core
    uds3_core = get_uds3_relations_core()

    try:
        # 1. Schema erstellen
        print("\n📊 NEO4J SCHEMA ERSTELLUNG...")
        schema_result = uds3_core.create_neo4j_schema(force_recreate=False)

        if schema_result["success"]:
            print("✅ Schema erfolgreich erstellt!")
            print(f"  Constraints: {len(schema_result['constraints_created'])}")
            print(f"  Indexes: {len(schema_result['indexes_created'])}")
            print(f"  Relations: {len(schema_result['relation_types_defined'])}")
        else:
            print(f"❌ Schema-Erstellung fehlgeschlagen: {schema_result['errors']}")

        # 2. Relations Schema testen
        print("\n🔍 RELATIONS SCHEMA INFORMATION...")

        # UDS3-spezifische Relations
        uds3_relations = [
            "UDS3_LEGAL_REFERENCE",
            "UDS3_SEMANTIC_REFERENCE",
            "PART_OF",
            "CONTAINS_CHUNK",
        ]

        for relation_type in uds3_relations:
            schema_info = uds3_core.get_relation_schema(relation_type)
            if "error" not in schema_info:
                print(f"\n📋 {relation_type}:")
                print(f"  Type: {schema_info['definition']['type']}")
                print(f"  Level: {schema_info['definition']['level']}")
                print(f"  UDS3 Priority: {schema_info['uds3_metadata']['priority']}")
                print(
                    f"  Performance Weight: {schema_info['uds3_metadata']['performance_weight']}"
                )
                print(
                    f"  KGE Importance: {schema_info['definition']['kge_importance']}"
                )

        # 3. Test Relation erstellen
        print("\n🔗 TEST RELATION ERSTELLUNG...")

        # Simuliere Relation-Erstellung (benötigt existierende Nodes)
        test_relation = uds3_core.create_relation(
            source_node_id="test_doc_001",
            target_node_id="test_chunk_001",
            relation_type="CONTAINS_CHUNK",
            properties={
                "chunk_index": 0,
                "total_chunks": 5,
                "chunk_order": [0, 1, 2, 3, 4],
            },
            source_node_type="Document",
            target_node_type="DocumentChunk",
        )

        if test_relation["success"]:
            print(f"✅ Test-Relation erstellt: {test_relation['relation_id']}")
            print(
                f"  Duration: {test_relation['performance_metrics']['duration_ms']}ms"
            )
        else:
            print(
                f"⚠️ Test-Relation nicht erstellt (Nodes existieren nicht): {test_relation['validation_errors']}"
            )

        # 4. Graph Konsistenz validieren
        print("\n🔍 GRAPH KONSISTENZ VALIDIERUNG...")
        validation = uds3_core.validate_graph_consistency()

        print(f"Graph konsistent: {'✅' if validation['overall_consistent'] else '❌'}")
        print(f"Validation Checks: {len(validation['validation_checks'])}")

        for check in validation["validation_checks"]:
            status_icon = (
                "✅"
                if check["status"] == "PASS"
                else "⚠️"
                if check["status"] == "WARNING"
                else "❌"
            )
            print(f"  {status_icon} {check['check_name']}: {check['details']}")

        if validation["inconsistencies"]:
            print("\n❌ Inkonsistenzen gefunden:")
            for inconsistency in validation["inconsistencies"]:
                print(f"  - {inconsistency}")

        # 5. Graph Statistiken
        print("\n📊 GRAPH STATISTIKEN:")
        stats = validation["statistics"]

        if "node_counts" in stats:
            print("  Node Types:")
            for node_type, count in stats["node_counts"].items():
                print(f"    {node_type}: {count:,}")

        if "relation_counts" in stats:
            print("  Top Relation Types:")
            for rel_type, count in list(stats["relation_counts"].items())[:10]:
                print(f"    {rel_type}: {count:,}")

        print("\n🎉 UDS3 Relations Core erfolgreich getestet!")

    except Exception as e:
        print(f"❌ Test fehlgeschlagen: {e}")

    finally:
        # Verbindung schließen
        uds3_core.close()